import React from 'react';
import './Stats.css';

interface Cell {
  letter: string;
  state: 'empty' | 'filled' | 'active' | 'black';
  label?: number;
  clue?: {
    across?: string;
    down?: string;
  };
}

interface WordInfo {
  number: number;
  direction: 'across' | 'down';
  length: number;
  clue?: string;
  isAutoGenerated?: boolean;
}

interface StatsTabProps {
  grid: Cell[][];
}

export const StatsTab: React.FC<StatsTabProps> = ({ grid }) => {

  const calculateStats = () => {
    let totalCells = 0;
    let filledCells = 0;
    let blackCells = 0;
    let emptyCells = 0;
    const words: WordInfo[] = [];
    const wordMap = new Map<string, WordInfo>();

    // Count cells and find words
    for (let i = 0; i < grid.length; i++) {
      for (let j = 0; j < grid[i].length; j++) {
        totalCells++;
        const cellState = grid[i][j].state;
        
        switch (cellState) {
          case 'filled':
            filledCells++;
            break;
          case 'black':
            blackCells++;
            break;
          case 'empty':
            emptyCells++;
            break;
        }

        // Find words (cells with labels)
        if (grid[i][j].label && !wordMap.has(`${grid[i][j].label}-across`)) {
          // Check across word
          let acrossLength = 0;
          let acrossClue = '';
          let acrossAutoGenerated = false;
                     for (let k = j; k < grid[i].length && grid[i][k]?.state !== 'black'; k++) {
             acrossLength++;
             if (grid[i][k]?.clue?.across) {
               acrossClue = grid[i][k]?.clue?.across || '';
               acrossAutoGenerated = (grid[i][k]?.clue?.across || '').includes('[AI]');
             }
           }
          if (acrossLength > 1) {
            const acrossWord: WordInfo = {
              number: grid[i][j].label!,
              direction: 'across',
              length: acrossLength,
              clue: acrossClue,
              isAutoGenerated: acrossAutoGenerated
            };
            words.push(acrossWord);
            wordMap.set(`${grid[i][j].label}-across`, acrossWord);
          }
        }

        if (grid[i][j].label && !wordMap.has(`${grid[i][j].label}-down`)) {
          // Check down word
          let downLength = 0;
          let downClue = '';
          let downAutoGenerated = false;
                     for (let k = i; k < grid.length && grid[k]?.[j]?.state !== 'black'; k++) {
             downLength++;
             if (grid[k]?.[j]?.clue?.down) {
               downClue = grid[k][j]?.clue?.down || '';
               downAutoGenerated = (grid[k][j]?.clue?.down || '').includes('[AI]');
             }
           }
          if (downLength > 1) {
            const downWord: WordInfo = {
              number: grid[i][j].label!,
              direction: 'down',
              length: downLength,
              clue: downClue,
              isAutoGenerated: downAutoGenerated
            };
            words.push(downWord);
            wordMap.set(`${grid[i][j].label}-down`, downWord);
          }
        }
      }
    }

    const acrossWords = words.filter(w => w.direction === 'across');
    const downWords = words.filter(w => w.direction === 'down');
    const cluesWritten = words.filter(w => w.clue && w.clue.trim() !== '').length;
    const autoGeneratedClues = words.filter(w => w.isAutoGenerated).length;

    const longestWord = words.reduce((max, word) => word.length > max.length ? word : max, words[0] || { length: 0, number: 0, direction: 'across' as const });
    const shortestWord = words.reduce((min, word) => word.length < min.length ? word : min, words[0] || { length: 0, number: 0, direction: 'across' as const });

    const meanWordLength = words.length > 0 ? words.reduce((sum, word) => sum + word.length, 0) / words.length : 0;

    // Check symmetry
    const isSymmetrical = checkSymmetry(grid);

    // Calculate word density (words per 5x5 section)
    const sections = Math.ceil(grid.length / 5) * Math.ceil(grid[0]?.length / 5);
    const wordDensity = sections > 0 ? words.length / sections : 0;

    return {
      totalCells,
      filledCells,
      blackCells,
      emptyCells,
      words,
      acrossWords,
      downWords,
      cluesWritten,
      autoGeneratedClues,
      fillPercentage: totalCells > 0 ? (filledCells / totalCells) * 100 : 0,
      meanWordLength,
      longestWord,
      shortestWord,
      isSymmetrical,
      wordDensity
    };
  };

  const checkSymmetry = (grid: Cell[][]) => {
    const size = grid.length;
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        const symRow = size - 1 - i;
        const symCol = size - 1 - j;
        if (grid[i][j].state !== grid[symRow][symCol].state) {
          return false;
        }
      }
    }
    return true;
  };

  const stats = calculateStats();

  const getProgressBarColor = (percentage: number) => {
    if (percentage >= 80) return 'var(--color-success)';
    if (percentage >= 60) return 'var(--color-warning)';
    return 'var(--color-error)';
  };

  const getWordDirectionLabel = (direction: 'across' | 'down') => {
    return direction === 'across' ? 'a' : 'd';
  };

  return (
    <div className="stats-content">
      {/* Grid Overview Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Grid Overview</h3>
        </div>
        <div className="stats-grid">
          <div className="stat-item">
            <span className="stat-label">Total Cells</span>
            <span className="stat-value">{stats.totalCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Filled Cells</span>
            <span className="stat-value filled">{stats.filledCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Empty Cells</span>
            <span className="stat-value empty">{stats.emptyCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Black Squares</span>
            <span className="stat-value black">{stats.blackCells}</span>
          </div>
        </div>
        
        {/* Fill Progress Bar */}
        <div className="progress-section">
          <div className="progress-header">
            <span className="progress-label">Grid Fill Progress</span>
            <span className="progress-percentage">{stats.fillPercentage.toFixed(1)}%</span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${stats.fillPercentage}%`,
                backgroundColor: getProgressBarColor(stats.fillPercentage)
              }}
            />
          </div>
        </div>
      </div>

      {/* Word Metrics Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Word Metrics</h3>
        </div>
        <div className="stats-grid">
          <div className="stat-item">
            <span className="stat-label">Total Words</span>
            <span className="stat-value">{stats.words.length}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Mean Length</span>
            <span className="stat-value">{stats.meanWordLength.toFixed(1)}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Longest Word</span>
            <span className="stat-value">
              {stats.longestWord.length} ({stats.longestWord.number}{getWordDirectionLabel(stats.longestWord.direction)})
            </span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Shortest Word</span>
            <span className="stat-value">
              {stats.shortestWord.length} ({stats.shortestWord.number}{getWordDirectionLabel(stats.shortestWord.direction)})
            </span>
          </div>
        </div>
      </div>



      {/* Progress Tracking Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Progress Tracking</h3>
        </div>
        
        {/* Clue Progress */}
        <div className="progress-section">
          <div className="progress-header">
            <span className="progress-label">Clues Written</span>
            <span className="progress-percentage">
              {stats.cluesWritten} / {stats.words.length}
            </span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${stats.words.length > 0 ? (stats.cluesWritten / stats.words.length) * 100 : 0}%`,
                backgroundColor: getProgressBarColor(stats.words.length > 0 ? (stats.cluesWritten / stats.words.length) * 100 : 0)
              }}
            />
          </div>
          {stats.autoGeneratedClues > 0 && (
            <div className="auto-generated-info">
              <span className="ai-tag">AI Generated: {stats.autoGeneratedClues}</span>
            </div>
          )}
        </div>

        {/* Direction Breakdown */}
        <div className="direction-breakdown">
          <div className="direction-item">
            <span className="direction-label">Across</span>
            <span className="direction-count">
              {stats.acrossWords.filter(w => w.clue && w.clue.trim() !== '').length} / {stats.acrossWords.length}
            </span>
          </div>
          <div className="direction-item">
            <span className="direction-label">Down</span>
            <span className="direction-count">
              {stats.downWords.filter(w => w.clue && w.clue.trim() !== '').length} / {stats.downWords.length}
            </span>
          </div>
        </div>
      </div>

      {/* Warnings Section */}
      {stats.shortestWord.length === 3 && (
        <div className="warning-section">
          <div className="warning-item">
            <span className="warning-text">Too many 3-letter words</span>
          </div>
        </div>
      )}
    </div>
  );
}; 