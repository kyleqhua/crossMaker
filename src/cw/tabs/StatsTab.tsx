import React from 'react';
import './Stats.css';

interface Cell {
  letter: string;
  state: 'empty' | 'filled' | 'active' | 'black';
  label?: number;
  clue?: {
    across?: string;
    down?: string;
  };
}

interface WordInfo {
  number: number;
  direction: 'across' | 'down';
  length: number;
  clue?: string;
  isAutoGenerated?: boolean;
}

interface StatsTabProps {
  grid: Cell[][];
}

export const StatsTab: React.FC<StatsTabProps> = ({ grid }) => {

  const calculateStats = () => {
    let totalCells = 0;
    let filledCells = 0;
    let blackCells = 0;
    let emptyCells = 0;
    const words: WordInfo[] = [];

    // Across words
    for (let i = 0; i < grid.length; i++) {
      let j = 0;
      while (j < grid[i].length) {
        // Find the start of a word
        while (j < grid[i].length && grid[i][j].state === 'black') j++;
        let start = j;
        while (j < grid[i].length && grid[i][j].state !== 'black') j++;
        let end = j;
        let length = end - start;
        if (length > 1) {
          words.push({
            number: (grid[i][start].label ?? 0), // Optional: you can omit or compute a number
            direction: 'across',
            length,
            clue: grid[i][start].clue?.across,
            isAutoGenerated: grid[i][start].clue?.across?.includes('[AI]') ?? false,
          });
        }
      }
    }

    // Down words
    for (let j = 0; j < grid[0].length; j++) {
      let i = 0;
      while (i < grid.length) {
        // Find the start of a word
        while (i < grid.length && grid[i][j].state === 'black') i++;
        let start = i;
        while (i < grid.length && grid[i][j].state !== 'black') i++;
        let end = i;
        let length = end - start;
        if (length > 1) {
          words.push({
            number: (grid[start][j].label ?? 0), // Optional: you can omit or compute a number
            direction: 'down',
            length,
            clue: grid[start][j].clue?.down,
            isAutoGenerated: grid[start][j].clue?.down?.includes('[AI]') ?? false,
          });
        }
      }
    }

    // Count cells
    for (let i = 0; i < grid.length; i++) {
      for (let j = 0; j < grid[i].length; j++) {
        totalCells++;
        const cellState = grid[i][j].state;
        switch (cellState) {
          case 'filled':
            filledCells++;
            break;
          case 'black':
            blackCells++;
            break;
          case 'empty':
            emptyCells++;
            break;
        }
      }
    }

    const acrossWords = words.filter(w => w.direction === 'across');
    const downWords = words.filter(w => w.direction === 'down');
    const cluesWritten = words.filter(w => w.clue && w.clue.trim() !== '').length;
    const autoGeneratedClues = words.filter(w => w.isAutoGenerated).length;

    const longestWord = words.reduce((max, word) => word.length > max.length ? word : max, words[0] || { length: 0, number: 0, direction: 'across' as const });
    const shortestWord = words.reduce((min, word) => word.length < min.length ? word : min, words[0] || { length: 0, number: 0, direction: 'across' as const });

    const meanWordLength = words.length > 0 ? words.reduce((sum, word) => sum + word.length, 0) / words.length : 0;

    // Check symmetry
    const isSymmetrical = checkSymmetry(grid);

    // Calculate word density (words per 5x5 section)
    const sections = Math.ceil(grid.length / 5) * Math.ceil(grid[0]?.length / 5);
    const wordDensity = sections > 0 ? words.length / sections : 0;

    return {
      totalCells,
      filledCells,
      blackCells,
      emptyCells,
      words,
      acrossWords,
      downWords,
      cluesWritten,
      autoGeneratedClues,
      fillPercentage: totalCells > 0 ? (filledCells / totalCells) * 100 : 0,
      meanWordLength,
      longestWord,
      shortestWord,
      isSymmetrical,
      wordDensity
    };
  };

  const checkSymmetry = (grid: Cell[][]) => {
    const size = grid.length;
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        const symRow = size - 1 - i;
        const symCol = size - 1 - j;
        if (grid[i][j].state !== grid[symRow][symCol].state) {
          return false;
        }
      }
    }
    return true;
  };

  const stats = calculateStats();

  const getProgressBarColor = (percentage: number) => {
    if (percentage >= 80) return 'var(--color-success)';
    if (percentage >= 60) return 'var(--color-warning)';
    return 'var(--color-error)';
  };

  const getWordDirectionLabel = (direction: 'across' | 'down') => {
    return direction === 'across' ? 'a' : 'd';
  };

  return (
    <div className="stats-content">
      {/* Grid Overview Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Grid Overview</h3>
        </div>
        <div className="stats-grid">
          <div className="stat-item">
            <span className="stat-label">Total Cells</span>
            <span className="stat-value">{stats.totalCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Filled Cells</span>
            <span className="stat-value filled">{stats.filledCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Empty Cells</span>
            <span className="stat-value empty">{stats.emptyCells}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Black Squares</span>
            <span className="stat-value black">{stats.blackCells}</span>
          </div>
        </div>
        
        {/* Fill Progress Bar */}
        <div className="progress-section">
          <div className="progress-header">
            <span className="progress-label">Grid Fill Progress</span>
            <span className="progress-percentage">{stats.fillPercentage.toFixed(1)}%</span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${stats.fillPercentage}%`,
                backgroundColor: getProgressBarColor(stats.fillPercentage)
              }}
            />
          </div>
        </div>
      </div>

      {/* Word Metrics Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Word Metrics</h3>
        </div>
        <div className="stats-grid">
          <div className="stat-item">
            <span className="stat-label">Total Words</span>
            <span className="stat-value">{stats.words.length}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Mean Length</span>
            <span className="stat-value">{stats.meanWordLength.toFixed(1)}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Longest Word</span>
            <span className="stat-value">
              {stats.longestWord.length} ({stats.longestWord.number}{getWordDirectionLabel(stats.longestWord.direction)})
            </span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Shortest Word</span>
            <span className="stat-value">
              {stats.shortestWord.length} ({stats.shortestWord.number}{getWordDirectionLabel(stats.shortestWord.direction)})
            </span>
          </div>
        </div>
      </div>

      {/* Progress Tracking Section */}
      <div className="stats-section">
        <div className="stats-section-header">
          <h3>Progress Tracking</h3>
        </div>
        
        {/* Clue Progress */}
        <div className="progress-section">
          <div className="progress-header">
            <span className="progress-label">Clues Written</span>
            <span className="progress-percentage">
              {stats.cluesWritten} / {stats.words.length}
            </span>
          </div>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${stats.words.length > 0 ? (stats.cluesWritten / stats.words.length) * 100 : 0}%`,
                backgroundColor: getProgressBarColor(stats.words.length > 0 ? (stats.cluesWritten / stats.words.length) * 100 : 0)
              }}
            />
          </div>
          {stats.autoGeneratedClues > 0 && (
            <div className="auto-generated-info">
              <span className="ai-tag">AI Generated: {stats.autoGeneratedClues}</span>
            </div>
          )}
        </div>

        {/* Direction Breakdown */}
        <div className="direction-breakdown">
          <div className="direction-item">
            <span className="direction-label">Across</span>
            <span className="direction-count">
              {stats.acrossWords.filter(w => w.clue && w.clue.trim() !== '').length} / {stats.acrossWords.length}
            </span>
          </div>
          <div className="direction-item">
            <span className="direction-label">Down</span>
            <span className="direction-count">
              {stats.downWords.filter(w => w.clue && w.clue.trim() !== '').length} / {stats.downWords.length}
            </span>
          </div>
        </div>
      </div>

      {/* Warnings Section */}
      {stats.shortestWord.length === 3 && (
        <div className="warning-section">
          <div className="warning-item">
            <span className="warning-text">Too many 3-letter words</span>
          </div>
        </div>
      )}
    </div>
  );
}; 